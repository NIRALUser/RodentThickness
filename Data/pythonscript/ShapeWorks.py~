#!/work/joohwi/Python/Python-build/bin/python
import sys
print sys.path

import os
from optparse import OptionParser
from vtk import vtkPolyDataReader, vtkPolyDataWriter, vtkThinPlateSplineTransform, vtkGeneralTransform, vtkTransformPolyDataFilter

def warp(srcLandmark,dstLandmark,subj):
  tps = vtkThinPlateSplineTransform()
  tps.SetSourceLandmarks(srcLandmark.GetPoints())
  tps.SetTargetLandmarks(dstLandmark.GetPoints())
  tps.SetBasisToR()

  t1 = vtkGeneralTransform()
  t1.SetInput(tps)

  tf = vtkTransformPolyDataFilter()
  tf.SetInputData(subj)
  tf.SetTransform(t1)
  tf.Update()

  warped = tf.GetOutput()
  return warped

def readvtk(fin):
  r = vtkPolyDataReader()
  r.SetFileName(fin)
  r.Update()
  mesh = r.GetOutput()
  return mesh

def writevtk(fin, mesh):
  r = vtkPolyDataWriter()
  r.SetFileName(fin)
  r.SetInputData(mesh)
  r.Write()


def vtk2lpts(inputSurfaces, outputPoints):
  for (fin, fout) in zip(inputSurfaces, outputPoints):
    mesh = readvtk(fin)
    points = mesh.GetPoints()
    fo = open(fout, "w")
    print "Converting %s into %s [%d points] ..." % (fin, fout, points.GetNumberOfPoints())
    for i in range(0, points.GetNumberOfPoints()):
      p = points.GetPoint(i)
      fo.write("%f %f %f\n" % (10*p[0],10*p[1],10*p[2])) 
    fo.close()

def file2string(fn):
  f = open(fn, "r")
  lines = f.readlines()
  return [ x.strip() for x in lines ]

def string2file(fn,str):
  f = open(fn, "w")
  f.write(str)
  f.close()

def execute(cmd):
  print "Executing %s ..." % (cmd)
  os.system(cmd)

def xml2dom(xml):
  return xml

def lpts2vtk(lptsIn, vtkTmpl, vtkOut):
  mesh = readvtk(vtkTmpl)
  for (fin, fout) in zip(lptsIn,vtkOut):
    lines = file2string(fin)
    points = [ [ float(f)*.1 for f in l.split(" ") ]  for l in lines ]
    meshPoints = mesh.GetPoints()
    if (meshPoints.GetNumberOfPoints() != len(points)):
      print "Mismatch between the template surface model and the corresponding points (%s) [%d:%d]" % (fin, meshPoints.GetNumberOfPoints(), len(points))
      continue
    for i in range(0, len(points)):
      meshPoints.SetPoint(i, points[i])
    mesh.SetPoints(meshPoints)
    writevtk(fout, mesh)
  return

def tpsWarp(sourceLandmark,targetLandmarks,deformationInput,finalSurfaces):
  src = readvtk(sourceLandmark)  
  deforming = readvtk(deformationInput)
  for (fin,fout) in zip(targetLandmarks,finalSurfaces):
    print "warping [%s => %s] : [%s => %s] ..." % (sourceLandmark, fin, deformationInput, fout)
    dst = readvtk(fin)
    warped = warp(src, dst, deforming)
    print "done!!"
    writevtk(fout, warped)
  return

def groom(imagesIn,imagesOut):
  tmpl = """<?xml version="1.0" ?>
<background>0.0</background>
<foreground>1.0</foreground> 
<pad>0</pad> 
<antialias_iterations>20</antialias_iterations> 
<blur_sigma>0.0625</blur_sigma> 
<fastmarching_isovalue>0.0</fastmarching_isovalue>  
<verbose>0</verbose>      
<inputs>          
##INPUTS##
</inputs>   
<outputs>           
##OUTPUTS##
</outputs>
  """
  tmpl = tmpl.replace("##INPUTS##", "\n".join(imagesIn))
  tmpl = tmpl.replace("##OUTPUTS##", "\n".join(imagesOut))
  string2file("groom.xml", tmpl)
  execute("%s %s isolate hole_fill antialias fastmarching blur" % (shapeWorksGroom, "groom.xml"))

def adjustSpacing(images):
  for f in images:
    execute("%s/ImageMath %s -type float -changeSp 1.25,1.25,1.25 -outfile %s" % (imageMathPath, f,f))
  
def run(inputImages,inputPoints):
  tmpl = """<?xml version="1.0" ?>
<inputs>        
###INPUTS###
</inputs>   
<point_files> 
###POINT_FILES###
</point_files>
<number_of_particles> 1002 </number_of_particles> 
<starting_regularization> 10.0 </starting_regularization> 
<ending_regularization> 0.1 </ending_regularization> 
<optimization_iterations> 100 </optimization_iterations> 
<checkpointing_interval> 20 </checkpointing_interval> 
<output_points_prefix> output </output_points_prefix> 
  """
  tmpl = tmpl.replace("###INPUTS###", "\n".join(inputImages)).replace("###POINT_FILES###", "\n".join(inputPoints))
  string2file("run.xml", tmpl)
  execute("%s %s" % (shapeWorksRun, "run.xml"))

def main(opts, args):
  toolPath = opts.pathShapeWorks
  shapeWorksRun = "%s/ShapeWorksRun" % (toolPath)
  shapeWorksGroom = "%s/ShapeWorksGroom" % (toolPath)
  imageMathPath = opts.pathImageMath
  inputImages = file2string(args[0])
  inputSurfaces = file2string(args[1])
  if (len(inputImages) != len(inputSurfaces)):
    print "Number of subjects doesn't match [%d:%d]" % (len(inputImages), len(inputSurfaces))
    return
  preprocessedImages = [ "%03d.DT.nrrd" % (i) for (i,f) in enumerate(inputImages) ]
  inputPoints = [ "%03d.initial.lpts" % (i) for (i,f) in enumerate(inputSurfaces) ]
  if (opts.correspondingOutputList == ""):
    outputSurfaces = [ f.replace(".vtk", ".out.vtk") for (i,f) in enumerate(inputSurfaces) ]
  else:
    outputSurfaces = file2string(opts.correspondingOutputList)
  if (opts.warpedOutputList == ""):
    warpedSurfaces = [ f.replace(".vtk", ".warped.vtk") for (i,f) in enumerate(inputSurfaces) ]
  else:
    warpedSurfaces = file2string(opts.warpedOutputList)
  if (len(inputSurfaces) < 10):
    correspondingPoints = [ "output.%01d.lpts" % (i) for (i,f) in enumerate(inputSurfaces) ]
  elif (len(inputSurfaces) < 100):
    correspondingPoints = [ "output.%02d.lpts" % (i) for (i,f) in enumerate(inputSurfaces) ]
  else:
    correspondingPoints = [ "output.%03d.lpts" % (i) for (i,f) in enumerate(inputSurfaces) ]
  groom(inputImages, preprocessedImages)
  adjustSpacing(preprocessedImages)
  vtk2lpts(inputSurfaces, inputPoints)
  run(preprocessedImages, inputPoints)
  lpts2vtk(correspondingPoints, inputSurfaces[0], outputSurfaces)
  tpsWarp(inputSurfaces[0],outputSurfaces,inputSurfaces[0],warpedSurfaces)
  return


if (__name__ =="__main__"):
  parser = OptionParser(usage="%prog [options] images_input surfaces_input")
  parser.add_option("--workingDir", dest="workingDirectory", help="change working directory where intermediate files such as parameters.xml and output.*.lpts are created.", default="")
  parser.add_option("-w", "--warpedOutputList", help="text file containing the list of warped output", dest="warpedOutputList", default="")
  parser.add_option("-c", "--correspondingOutputList", help="text file containing the list of corresponding surfaces", dest="correspondingOutputList", default="")
  parser.add_option("--pathShapeWorks", help="tool path for shape Works",dest="pathShapeWorks", default="/NIRAL/devel/linux/ShapeWorks")
  parser.add_option("--pathImageMath", help="path for ImageMath", dest="pathImageMath", default="/tools/bin_linux64/ImageMath")
  (opts, args) = parser.parse_args()

  if (opts.workingDirectory != ""):
    os.chdir(opts.workingDirectory)

  if (len(args) == 2):
    main(opts, args)
